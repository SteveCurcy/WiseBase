# 迭代器模式

*迭代器模式* 让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素。

## 背景

集合是编程中最常用的数据结构之一，它们底层的结构各不相同。但不论使用什么结构，都应该提供一种遍历元素的方式。比如对于一棵树，你可能需要深度优先算法遍历，又可能使用广度优先算法。

不断向集合中添加遍历算法会模糊其“高效存储数据”的主要职责。此外，有些算法可能是根据特定应用订制的，将其加入泛型集合类中会显得非常奇怪。

此外，使用多种集合的客户端代码可能并不关心存储数据的方式。不过由于集合提供不同的元素访问方式，你的代码将不得不与特定集合类进行耦合。

## 解决方案

迭代器模式的主要思想是将集合的遍历行为抽取为单独的 *迭代器* 对象。

除实现自身算法外，迭代器还封装了遍历操作的所有细节，例如当前位置和末尾剩余元素的数量。因此，多个迭代器可以在相互独立的情况下同时访问集合。

迭代器通常会提供一个获取集合元素的基本方法。客户端可不断调用该方法直至它不返回任何内容，这意味着迭代器已经遍历了所有元素。

所有迭代器必须实现相同的接口。这样一来，只要有合适的迭代器，客户端代码就能兼容任何类型的集合或遍历算法。如果你需要采用特殊方式来遍历集合，只需创建一个新的迭代器类即可，无需对集合或客户端进行修改。

## 迭代器模式结构

![迭代器设计模式的结构](../../assets/imgs/DP-Iterator-structure.png)

- 迭代器 (Iterator)：声明遍历集合所需的操作接口，获取下一个元素、获取当前位置、重新迭代等；
- 具体迭代器 (Concrete Iterator)：实现遍历集合的一种特定算法，迭代器对象必须跟踪自身遍历的进度，这使得多个迭代器可以相互独立地遍历同一集合；
- 集合 (Collection)：其接口声明一个或多个方法来获取与集合兼容的迭代器，<mark>返回方法的类型必须被声明为迭代器接口</mark>，因此具体集合可以返回各种不同种类的迭代器；
- 具体集合 (Concrete Collections)：在客户端请求迭代器时返回一个特定的具体迭代器类实体；

客户端通过集合和迭代器的接口与两者进行交互，这样一来客户端无需与具体类进行耦合，允许同一客户端代码使用各种不同的集合和迭代器。

客户端通常不会自行创建迭代器，而是会从集合中获取。但在特定情况下，客户端可以直接创建一个迭代器。

## 参考

[迭代器设计模式](https://refactoringguru.cn/design-patterns/iterator)
# 单例模式

*单例模式* Singleton 的特点是只提供唯一一个类的实例，任何位置都可以通过接口获得唯一实例。当需要系统中只有唯一一个类实例存在时才使用单例模式，使用单例的时候要注意<mark>越小越好，越简单越好，线程安全，内存不泄漏</mark>。

最常用的也是最推荐的单例模式的实现，是由 Meyers 提出的使用 Magic Static 特性的单例：

```c++
class Singleton {
  Singleton() {}
public:
  ~Singleton() {}
  Singleton(const Singleton&) = delete;
  Singleton& operator=(const Singleton&) = delete;
  static Singleton& get_instance() {
    static Singleton instance;
    return instance;
  }
}
```

Magic Static 特性：如果当变量在初始化时，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。这就保证了并发线程在获取静态局部变量的时候一定是初始化过的。这里单例模式只保证实例初始化时的线程安全，至于操作实例时的线程安全需要各线程自己加锁保证。

静态变量的生命周期从声明到程序结束。这是一种懒汉式单例模式，即只有当调用 `get_instance` 时才会创建实例，否则就不会创建。这种方式不需要使用智能指针，方便使用。此外，<mark>获取实例的方法返回值是引用而非指针，这是为了防止返回指针，而开发者主动调用 `delete` 导致实例提前被销毁</mark>。

**为什么将实例声明为成员变量而是局部变量？**

如果是静态成员变量，则通常是该类的指针(因为静态成员变量的初始化应该在类外)，在调用方法是执行 new 创建新的实例。这将带来线程安全问题，而为了解决线程安全问题则需要加锁，大量的加锁和判断操作会增加程序的开销；

此外，使用静态成员变量，应该使用智能指针来保证实例在程序结束时能够被释放，但是这要求使用单例的开发者也需要会使用智能指针。但是单例模式要求代码要尽量简单并且不应该提出这样的额外约束。
# C++11新特性

:point_right: 本文改自 [c++11新特性(知乎)](https://zhuanlan.zhihu.com/p/139515439)。:point_left:

[TOC]

## 1. auto & decltype

关于 C++11 新特性，最先提到的肯定是类型推导，C++11 引入了 auto 和 decltype 关键字，使用他们可以在==编译期==就推导出变量或者表达式的类型，方便开发者编码也简化了代码。

### 1.1. auto

auto 可以让编译器在编译期就推导出变量的类型：

```c++
auto a = 10; // 10是int型，可以自动推导出a是int

int i = 10;
auto b = i; // b是int型

auto d = 2.0; // d是double型
```

#### auto 推导规则

```c++
int i = 10;
auto a = i, &b = i, *c = &i; // a是int，b是i的引用，c是i的指针，auto就相当于int
auto d = 0, f = 1.0; // error，0和1.0类型不同，对于编译器有二义性，没法推导
auto e; // error，使用auto必须马上初始化，否则无法推导类型

void func(auto value) {} // error，auto不能用作函数参数

class A {
    auto a = 1; // error，在类中auto不能用作非静态成员变量
    static auto b = 1; // error，这里与auto无关，正常static int b = 1也不可以
    static const auto c = 1; // ok
};

void func2() {
    int a[10] = {0};
    auto b = a; // ok
    auto c[10] = a; // error，auto不能定义数组，可以定义指针
    vector<int> d;
    vector<auto> f = d; // error，auto无法推导出模板参数
}
```

#### auto 限制

- auto 的使用必须马上初始化，否则无法推导出类型
- auto 在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败

- auto 不能用作函数参数
- 在类中 auto 不能用作非静态成员变量

- auto 不能定义数组，可以定义指针
- auto 无法推导出模板参数

```c++
int i = 0;
auto *a = &i; // a是int*
auto &b = i; // b是int&
auto c = b; // c是int，忽略了引用

const auto d = i; // d是const int
auto e = d; // e是int

const auto& f = e; // f是const int&
auto &g = f; // g是const int&
```

对于 const 和 volatile（下简称cv）

> volatile 告诉编译器，不要对该变量进行编译优化，因为该变量随时有可能改变，因此一定要存储到内存中。

- 在不声明为引用或指针时，auto 会忽略等号右边的引用类型和 cv 限定
- 在声明为引用或者指针时，auto 会保留等号右边的引用和 cv 属性

:question: 什么时候用 auto

通常在不影响代码可读性的前提下可以尽量使用 auto，对于简单的基本数据类型没必要使用 auto。通常类型太过复杂，建议使用 auto，因为人为指定容易出错且难记：

```c++
auto func = [&] {
        cout << "xxx";
}; // 对于func建议使用auto，因为无需关心lambda表达式究竟是什么类型。

auto asyncfunc = std::async(std::launch::async, func);
// 对于asyncfunc建议使用auto，std::futurexxx等类型太过复杂难记且易出错。
```

### 1.2. decltype

上面介绍 auto 用于推导变量类型，而 decltype 则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算：

```c++
int func() { return 0; }
decltype(func()) i; // i为int类型

int x = 0;
decltype(x) y; // y是int类型
decltype(x + y) z; // z是int类型
```

:exclamation: 注意：decltype 不会像 auto 一样忽略引用和 cv 属性，decltype 会保留表达式的引用和 cv 属性。

```c++
const int &i = 1;
int a = 2;
decltype(i) b = 2; // b是const int&
```

#### decltype推导规则

对 `decltype(exp)` 有

- exp 是表达式，`decltype(exp)` 和 exp 类型相同
- exp 是函数调用，`decltype(exp)` 和函数返回值类型相同
- 其它情况，若 exp 是左值，`decltype(exp)` 是 exp 类型的左值引用

```c++
int a = 0, b = 0;
decltype(a + b) c = 0; // c是int，因为(a+b)返回一个右值
decltype(a += b) d = c;// d是int&，因为(a+=b)返回一个左值

d = 20;
cout << "c " << c << endl; // 输出c 20
```

### 1.3. auto 和 decltype 的配合使用

auto 和 decltype 一般配合使用在推导函数返回值的类型问题上。

```c++
template<typename T, typename U>
return_value add(T t, U u) { // t和v类型不确定，无法推导出return_value类型
    return t + u;
}
```

上面代码由于 t 和 u 类型不确定，那如何推导出返回值类型呢，我们可能会想到这种

```c++
template<typename T, typename U>
decltype(t + u) add(T t, U u) { // t和u尚未定义
    return t + u;
}
```

这段代码在 C++11 上是编译不过的，因为在 `decltype(t + u)` 推导时，t 和 u 尚未定义，就会编译出错，所以有了下面的叫做“返回类型后置”的配合使用方法：

```c++
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```

返回值后置类型语法就是为了解决函数返回制类型依赖于参数但却难以确定返回值类型的问题。

在 C++14 以后可以使用 `decltype(auto)` 来推导返回值。

## 2. 左值右值

### 2.1. 左值右值

左值：可以放到等号左边的，或可以取地址并且有名字的就是左值。

右值：不能放到等号左边，不能取地址且无名的就是右值。

```c++
/* a是左值，a有变量名，也可以取地址，可以放到等号左边, 表达式b+c的返回值是右值，没有名字且不能取地址，&(b+c) 不能通过编译，而且也不能放到等号左边。 */
int a = b + c;
int d = 4;	// d是左值，4作为普通字面量是右值
```

左值一般有：

- 函数名和变量名
- 返回左值引用的函数调用
- 前置自增自减表达式 `++i、--i`
- 由赋值表达式或赋值运算符连接的表达式(`a=b, a += b` 等)
- 解引用表达式 `*p`
- 字符串字面值 `"abcd"`
- 纯右值、将亡值

纯右值和将亡值都属于右值。

:point_right: 纯右值

运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda 表达式等都是纯右值。

- 除字符串字面值外的字面值
- 返回非引用类型的函数调用
- 后置自增自减表达式 `i++、i--`
- 算术表达式(`a+b, a*b, a&&b, a==b` 等)
- 取地址表达式等(`&a`)

:point_right: 将亡值

将亡值是指 C++11 新增的和右值引用相关的表达式，通常指将要被移动的对象、T&& 函数的返回值、`std::move` 函数的返回值、转换为 T&& 类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过"盗取"其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。

#### 左值引用、右值引用

根据名字大概就可以猜到意思，左值引用就是对左值进行引用的类型，右值引用就是对右值进行引用的类型，他们都是引用，都是对象的一个别名，并不拥有所绑定对象的堆存，所以都必须立即初始化。

```c++
type &name = exp; // 左值引用
type &&name = exp; // 右值引用
```

:one: 左值引用

```c++
int a = 5;
int &b = a; // b是左值引用
b = 4;
int &c = 10; // error，10无法取地址，无法进行引用
const int &d = 10; // ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址
```

可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用 const 引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。此外，因为右值引用得到了右值的地址，本身也是右值的一个别名，所以可以被左值引用。

```c++
int &&a = 1;	// rvalue reference
int &b = a;		// ok! variable 'a' has name and address, and you can print its address.
cout << "a: " << &a << endl;
cout << "b: " << &b << endl;	// they will have the same address.
```

:two: 右值引用

如果使用右值引用，那表达式等号右边的值需要时右值，可以使用 `std::move` 函数强制把左值转换为右值。

```c++
int a = 4;
int &&b = a; // error, a是左值
int &&c = std::move(a); // ok
```

### 2.2. 移动语义

#### 深拷贝、浅拷贝

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = a.data_;
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b(a);
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

上面代码中，两个输出的是相同的地址，a 和 b 的 data\_ 指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时 data\_ 内存会被释放两次，导致程序出问题，这里正常会出现 double free 导致程序崩溃的，这样的程序肯定是有隐患的，如何消除这种隐患呢，可以使用如下深拷贝：

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i++) {
            data_[i] = a.data_[i];
        }
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b(a);
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值。

#### 移动语义

移动语义，可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过 C++11 新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数。

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i++) {
            data_[i] = a.data_[i];
        }
        cout << "copy " << endl;
    }
    A(A&& a) {
        this->data_ = a.data_;
        a.data_ = nullptr;
        cout << "move " << endl;
    }
    ~A() {
        if (data_ != nullptr) {
            delete[] data_;
        }
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b(a);
    A c(std::move(a)); // 调用移动构造函数
    return 0;
}
```

如果不使用 `std::move`，会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++ 所有的 STL 都实现了移动语义，方便我们使用。例如：

```c++
std::vector<string> vecs;
...
std::vector<string> vecm(std::move(vecs)); // 免去很多拷贝
```

注意：移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型 int、float 等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。

<mark>注意</mark>：这里的 move 函数以及后面提及的 forward 函数使用时最好指明命名空间，即 `std::move, std::forward`，即使你已经使用了 `using namespace std;`。

#### 完美转发

完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用 `std::forward`。

```c++
void PrintV(int &t) {
    cout << "lvalue" << endl;
}

void PrintV(int &&t) {
    cout << "rvalue" << endl;
}

template<typename T>
void Test(T &&t) {
    PrintV(t);
    PrintV(std::forward<T>(t));

    PrintV(std::move(t));
}

int main() {
    Test(1); // lvalue rvalue rvalue
    int a = 1;
    Test(a); // lvalue lvalue rvalue
    Test(std::forward<int>(a)); // lvalue rvalue rvalue
    Test(std::forward<int&>(a)); // lvalue lvalue rvalue
    Test(std::forward<int&&>(a)); // lvalue rvalue rvalue
    return 0;
}
```

- Test(1)：1 是右值，模板中 `T &&t` 这种为万能引用，右值 1 传到 Test 函数中变成了右值引用，是调用 PrintV() 时候，传入的是 t，是有名字和地址的左值，所以打印 lvalue，而 `PrintV(std::forward(t))` 时候，会进行完美转发，按照原来的类型转发，所以打印 rvalue，`PrintV(std::move(t))` 毫无疑问会打印rvalue。
- Test(a)：a 是左值，模板中 `T &&` 这种为万能引用，左值 a 传到 Test 函数中变成了左值引用。
- `Test(std::forward<T>(a))`：转发为左值还是右值，依赖于 T，T 是左值那就转发为左值，T 是右值那就转发为右值。

#### 返回值优化

返回值优化 (RVO) 是一种 C++ 编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余地调用到，有代价，而通过返回值优化，C++ 标准允许省略调用这些复制构造函数。编译器在下列情况时会进行返回值优化：

- return 的值类型与函数的返回值类型相同
- return 的是一个局部对象

这里为了方便观察返回值优化的机制，给出如下类：

```c++
class test {
public:
    int a;

    test(){}

    test(int _a): a(_a){
        cout << "constructor:" << this << endl;
    }

    test(const test& t) {
        a = t.a;
        cout << "copy:" << this << endl;
    }

    test(test&& t) {
        a = t.a;
        cout << "move:" << this << endl;
    }

    ~test() {
        cout << "destructor:" << this << endl;
    }
};
```

首先，考虑普通情况，返回函数中的局部变量，并且定义变量接收返回值，这将触发 RVO。

```c++
test return_test() {
		return test{1};
}
test rval_ref = return_test();
```

其次，我们尝试使用各种函数返回来查看函数返回是如何工作的：

```c++
test return_test() {
  	return test{1};
}
test &&rval_ref = return_test();
```

这样不会触发 RVO，但是返回值会直接与 `rval_ref` 进行绑定，也不会出现多余的拷贝和临时变量的创建。

```c++
test&& return_test() {
  	/*
  	test t{1};
  	return t;	// error!!!
  	*/
  	return test{1};
}
test &&rval_ref = return_test();
test rval = return_test();
```

当返回值是右值引用时，不能定义变量，然后直接 return，但是这里返回的时候构造函数构造的临时变量，由于没有定义名字，所以是右值。

- 对于使用 `test` 接收返回值的情况，由于返回的是右值，所以会导致一次移动拷贝，然后释放函数中局部变量的空间。
- 而对于使用 `test&&` 接收的情况，因为使用右值引用接收一个右值，所以不调用构造函数。

## 3. 列表初始化

C++11 中新增了列表初始化的概念，即可以直接在变量名后面加初始化列表来进行对象的初始化。

```c++
struct A {
public:
    A(int) {}
private:
    A(const A&) {}
};
int main() {
    A a(123);
    A b = 123; // error
    A c = { 123 };	// the same as c(123)/c({123})
    A d{123}; // c++11

    int e = {123};
    int f{123}; // c++11

    return 0;
}
```

此外，初始化列表也可以用于函数的返回值。

```c++
std::vector<int> func() {
    return {};
}
```

### 3.1. 初始化列表的一些规则

聚合类型可以直接进行列表初始化，先来了解一下什么是聚合类型：

:one: 类型是一个普通数组，如 `int[5],char[],double[]` 等。

:two: 类型是一个类且满足以下条件：

- 没有用户声明的构造函数
- 没有用户提供的（允许显示预置或弃置的）构造函数
- 没有私有或保护的非静态数据成员
- 没有基类
- 没有虚函数
- 没有 {} 和 = 直接初始化的非静态成员函数
- 没有默认成员初始化器

```c++
struct A {
    int a;
    int b;
    int c;
    A(int, int){}
};
int main() {
    A a{1, 2, 3};// error，A有自定义的构造函数，不能列表初始化
}
struct A {
    int a;
    int b;
    virtual void func() {} // 含有虚函数，不是聚合类
};

struct Base {};
struct B : public Base { // 有基类，不是聚合类
    int a;
    int b;
};

struct C {
    int a;
    int b = 10; // 有等号初始化，不是聚合类
};

struct D {
    int a;
    int b;
private:
    int c; // 含有私有的非静态数据成员，不是聚合类
};

struct E {
    int a;
    int b;
    E() : a(0), b(0) {} // 含有默认成员初始化器，不是聚合类
};
```

上面列举了一些不是聚合类的例子，对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值；对于非聚合类型，需要先自定义一个对应的构造函数，此时列表初始化将调用相应的构造函数。

### 3.2. std::initializer_list

我们平时开发使用 STL 过程中可能发现它的初始化列表可以是任意长度，大家有没有想过它是怎么实现的呢，答案是 `std::initializer_list`，看下面这段示例代码：

```c++
struct CustomVec {
    std::vector<int> data;
    CustomVec(std::initializer_list<int> list) {
        for (auto iter = list.begin(); iter != list.end(); ++iter) {
            data.push_back(*iter);
        }
    }
};
```

我想通过上面这段代码大家可能已经知道STL是如何实现的任意长度初始化了吧，这个 `std::initializer_list` 其实也可以作为函数参数。

==注意==：`std::initializer_list`，它可以接收任意长度的初始化列表，但是里面必须是相同类型 T，或者都可以转换为 T。此外，列表元素之间的相互顺序是按照类型定义中的先后顺序确定的，而构造函数却没有这样的限制。

### 3.3. 列表初始化的优势

1. 方便且基本可以代替括号初始化
2. 使用初始化列表可以接受任意长度
3. 防止类型窄化，避免精度丢失的隐式类型转换

什么是类型窄化:question:列表初始化通过禁止下列转换对隐式转化加以限制：

- 从浮点类型到整数类型的转换
- 从 `long double` 到 `double` 或 `float` 的转换，以及从 `double` 到 `float` 的转换，除非源是常量表达式且不发生溢出。
- 从整数类型到浮点类型的转换，除非源是其值能完全存储于目标类型的常量表达式
- 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是其值能完全存储于目标类型的常量表达式

```c++
int main() {
    int a = 1.2; // ok
    int b = {1.2}; // error

    float c = 1e70; // ok
    float d = {1e70}; // error

    float e = (unsigned long long)-1; // ok
    float f = {(unsigned long long)-1}; // error
    float g = (unsigned long long)1; // ok
    float h = {(unsigned long long)1}; // ok

    const int i = 1000;
    const int j = 2;
    char k = i; // ok
    char l = {i}; // error

    char m = j; // ok
    char m = {j}; // ok，因为是const类型，这里如果去掉const属性，也会报错
}
```

## 4. std::function & std::bind & lambda 表达式

c++11 新增 `std::function、std::bind、lambda` 表达式等封装使函数调用更加方便。

### 4.1. std::function

要了解 `std::function` 首先要了解什么事可调用对象，满足以下条件之一的就可以称为可调用对象：

- 函数指针
- 具有 `operator()` 成员函数的类对象（仿函数），`lambda` 表达式
- 可被转换为函数指针的类对象
- 类成员函数指针
- `bind` 表达式或其他函数对象

而 `std::function` 就是上面这种可调用对象的封装器，可以把 `std::function` 看做一个函数对象，用于表示函数这个抽象概念。`std::function` 的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为 `std::function` 的目标，若 `std::function` 不含目标，则称它为空，调用空的 `std::function` 的目标会抛出 `std::bad_function_call` 异常。

```c++
std::function<void(int)> f; // 这里表示function的对象f的参数是int，返回值是void
#include <functional>
#include <iostream>

struct Foo {
    Foo(int num) : num_(num) {}
    void print_add(int i) const { std::cout << num_ + i << '\n'; }
    int num_;
};

void print_num(int i) { std::cout << i << '\n'; }

struct PrintNum {
    void operator()(int i) const { std::cout << i << '\n'; }
};

int main() {
    // 存储自由函数
    std::function<void(int)> f_display = print_num;
    f_display(-9);

    // 存储 lambda
    std::function<void()> f_display_42 = []() { print_num(42); };
    f_display_42();

    // 存储到 std::bind 调用的结果
    std::function<void()> f_display_31337 = std::bind(print_num, 31337);
    f_display_31337();

    // 存储到成员函数的调用
    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
    const Foo foo(314159);
    f_add_display(foo, 1);
    f_add_display(314159, 1);

    // 存储到数据成员访问器的调用
    std::function<int(Foo const&)> f_num = &Foo::num_;
    std::cout << "num_: " << f_num(foo) << '\n';

    // 存储到成员函数及对象的调用
    using std::placeholders::_1;
    std::function<void(int)> f_add_display2 = std::bind(&Foo::print_add, foo, _1);
    f_add_display2(2);

    // 存储到成员函数和对象指针的调用
    std::function<void(int)> f_add_display3 = std::bind(&Foo::print_add, &foo, _1);
    f_add_display3(3);

    // 存储到函数对象的调用
    std::function<void(int)> f_display_obj = PrintNum();
    f_display_obj(18);
}
```

从上面可以看到 `std::function` 的使用方法，当给 `std::function` 填入合适的参数表和返回值后，它就变成了可以容纳所有这一类调用方式的函数封装器。`std::function` 还可以用作回调函数，或者在 C++ 里如果需要使用回调那就一定要使用 `std::function`，特别方便。

### 4.2. std::bind

使用 `std::bind` 可以将可调用对象和参数一起绑定，绑定后的结果使用 `std::function` 进行保存，并延迟调用到任何我们需要的时候。

`std::bind` 通常有两大作用：

- 将可调用对象与参数一起绑定为另一个 `std::function` 供调用
- 将 n 元可调用对象转成 m (m < n) 元可调用对象，绑定一部分参数，这里需要使用 `std::placeholders`

```c++
#include <functional>
#include <iostream>
#include <memory>

void f(int n1, int n2, int n3, const int& n4, int n5) {
    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << std::endl;
}

int g(int n1) { return n1; }

struct Foo {
    void print_sum(int n1, int n2) { std::cout << n1 + n2 << std::endl; }
    int data = 10;
};

int main() {
    using namespace std::placeholders;  // 针对 _1, _2, _3...

    // 演示参数重排序和按引用传递
    int n = 7;
    // （ _1 与 _2 来自 std::placeholders ，并表示将来会传递给 f1 的参数）
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001);  // 1 为 _1 所绑定， 2 为 _2 所绑定，不使用 1001
                     // 进行到 f(2, 42, 1, n, 7) 的调用

    // 嵌套 bind 子表达式共享占位符
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12);  // 进行到 f(12, g(12), 12, 4, 5); 的调用

    // 绑定指向成员函数指针
    Foo foo;
    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
    f3(5);

    // 绑定指向数据成员指针
    auto f4 = std::bind(&Foo::data, _1);
    std::cout << f4(foo) << std::endl;

    // 智能指针亦能用于调用被引用对象的成员
    std::cout << f4(std::make_shared<Foo>(foo)) << std::endl;
}
```

### 4.3. lambda表达式

lambda 表达式可以说是 c++11 引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：

```c++
auto func = [capture] (params) opt -> ret { func_body; };
```

其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt 是函数选项 (mutable 之类)， ret 是返回值类型，func_body 是函数体。很多时候 lambda 表达式返回值是很明显的，c++11 允许省略表达式的返回值定义。

lambda 表达式允许捕获一定范围内的变量：

- [] 不捕获任何变量
- [&] 引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用

- [=] 值捕获，捕获外部作用域所有变量，在函数作为副本使用
- [=, &a] 值捕获外部作用域所有变量，按引用捕获 a 变量

- [a] 只值捕获 a 变量，不捕获其它变量
- [this] 捕获当前类中的 this 指针

```c++
int a = 0;
auto f1 = [=](){ return a; }; // 值捕获a
cout << f1() << endl;

auto f2 = [=]() { return a++; }; // 修改按值捕获的外部变量，error
auto f3 = [=]() mutable { return a++; };
```

lambda 表达式就相当于是一个仿函数，仿函数是一个有 `operator()` 成员函数的类对象，这个 operator() 默认是 const 的，所以不能修改成员变量，而加了 mutable，就是去掉 const 属性。

还可以使用 lambda 表达式自定义 STL 的规则，例如自定义 sort 排序规则：

```c++
struct A {
    int a;
    int b;
};

int main() {
    vector<A> vec;
    std::sort(vec.begin(), vec.end(), [](const A &left, const A &right) { return left.a < right.a; });
}
```

## 5. 模板的改进

### 5.1. 模板的右尖括号

C++11 之前是不允许两个右尖括号出现的，会被认为是右移操作符，所以需要中间加个空格进行分割，避免发生编译错误。

### 5.2. 模板别名

C++11 引入了 using，可以轻松的定义别名，而不是使用繁琐的 typedef。using 可以嵌套template，typedef 不行。

```c++
typedef std::vector<std::vector<int>> vvi; // before c++11
using vvi = std::vector<std::vector<int>>; // c++11

template<class T>
struct Alloc { };
template<class T>
using Vec = vector<T, Alloc<T>>; // 类型标识为 vector<T, Alloc<T>>，嵌套模板，如果使用typedef则将报错
Vec<int> v; // Vec<int> 同 vector<int, Alloc<int>>
```

使用 using 相比 typedef 明显简洁并且易读

```c++
typedef void (*func)(int, int);
using func = void (*)(int, int);
```

### 5.3. 函数模板的默认模板参数

C++11 之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，C++11 后都支持。

```c++
template <typename T, typename U=int>
class A {
    T value;  
};

template <typename T=int, typename U> // error
class A {
    T value;  
};
```

类模板的默认模板参数必须从右往左定义，而函数模板则没有这个限制。

```c++
template <typename R, typename U=int>
R func1(U val) {
    return val;
}

template <typename R=int, typename U>
R func2(U val) {
    return val;
}

int main() {
    cout << func1<int, double>(99.9) << endl; // 99
    cout << func1<double, double>(99.9) << endl; // 99.9
    cout << func1<double>(99.9) << endl; // 99.9
    cout << func1<int>(99.9) << endl; // 99
    cout << func2<int, double>(99.9) << endl; // 99
    cout << func1<double, double>(99.9) << endl; // 99.9
    cout << func2<double>(99.9) << endl; // 99.9
    cout << func2<int>(99.9) << endl; // 99
    return 0;
}
```

对于函数模板，参数的填充顺序是从左到右的。同时 C++11 支持变长参数模板：

```c++
template <typename T>
void func(const T& t){
    cout << t << endl;
}

template <typename T, typename ... Args>
void func(const T& t, Args ... args){
    cout << t << ',';
    func(args...);
}
```

可以通过 `sizeof...()` 获得参数个数，通过递归或包展开等方式来处理参数。

关于可变参数模板可以参照 [【C++】C++11可变参数模板（函数模板、类模板）_Yngz_Miao的博客-CSDN博客_c++ 可变模板](https://blog.csdn.net/qq_38410730/article/details/105247065)、[C++的可变参数模板 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/104450480)。

## 6. 并发

:point_right: 参考 [C++ 多线程](https://blog.csdn.net/sjc_0910/article/details/118861539)。:point_left:

### 6.1. std::thread

C 中有 pthread 来实现多线程编程，但是需要操作具柄、设置回调函数等，使用复杂，因而 C++11 中推出了 `std::thread`。

#### 常用成员函数

|                             函数                             |      类别      |                             作用                             |
| :----------------------------------------------------------: | :------------: | :----------------------------------------------------------: |
|                      Thread() noexcept                       |  默认构造函数  |                   创建一个线程，不做任何事                   |
| template <class Fn, class… Args><br />explicit thread(Fn&& fn, Args&&… args) | 初始化构造函数 |            创建一个线程，以args为参数，执行fn函数            |
|                 thread(thread&& x) noexcept                  |  移动构造函数  |            构造一个与`x`相同的对象，会破坏`x`对象            |
|                          ~thread()                           |    析构函数    |                           析构对象                           |
|                         void join()                          |                |                    等待线程结束并清理资源                    |
|                       bool joinable()                        |                |                 返回线程是否可以执行join函数                 |
|                        void detach()                         |                | 将线程与调用它的线程分离，彼此独立执行（此函数必须在线程创建时立即调用，且会使其不能被join） |
|                   Std::thread::id get_id()                   |                |                           获取pid                            |
|               thread& operator=(thread&& rhs)                |                | 见移动构造函数（如果对象是joinable的，则会调用`std::terminate()`结束程序） |

对于带有引用参数的函数，由于 `Args&&... args` 是右值引用，如果想要传递左值，则需要使用 `std::ref,std::cref` 来解决该问题。

:point_right: `std::ref` 可以包装引用传递的值

:point_right: `std::cref` 可以包装const引用传递的值

```c++
#include <iostream>
#include <thread>
using namespace std;
template<class T> void changevalue(T &x, T val) {
    x = val;
}
int main() {
    thread th[100];
    int nums[100];
    for (int i = 0; i < 100; i++)
        th[i] = thread(changevalue<int>, ref(nums[i]), i+1);
    for (int i = 0; i < 100; i++) {
        th[i].join();
        cout << nums[i] << endl;
    }
		return 0;
}
```

#### 注意事项

- 线程是在 thread 对象被定义的时候开始执行的，而不是在调用 join 函数时才执行的，调用 join 函数只是阻塞等待线程结束并回收资源。
- 分离的线程（执行过 detach 的线程）会在调用它的线程结束或自己结束时释放资源。
- 线程会在函数运行完毕后自动释放，不推荐利用其他方法强制结束线程，可能会因资源未释放而导致内存泄漏。
- 没有执行 `join` 或 `detach` 的线程在程序结束时会引发异常。

### 6.2. std::atomic 和 std::mutex

多线程在运行的过程中可能出现操作同一个变量，即出现资源的竞争，因此需要 `std::atomic` 和 `std::mutex` 来解决同步和互斥的问题。

#### std::mutex

这是 C++11 最基本的互斥量，一个线程将 mutex 锁住时，其他的线程就不能操作 mutex，直到该线程将其解锁。

```c++
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;
int n = 0;
mutex mtx;
void count10000() {
    for (int i = 1; i <= 10000; i++) {
        mtx.lock();
        n++;
        mtx.unlock();
    }
}
int main() {
    thread th[100];
    for (thread &x : th)
        x = thread(count10000);
    for (thread &x : th)
        x.join();
    cout << n << endl;
    return 0;
}
```

#### std::atomic

mutex 很好地解决了多线程资源争抢的问题，但是其执行速度太慢了，每次操作都需要加锁解锁，会浪费很多时间。因此，可以使用 atomic。

```c++
#include <iostream>
#include <thread>
// #include <mutex> //这个例子不需要mutex了
#include <atomic>
using namespace std;
atomic_int n = 0;
void count10000() {
    for (int i = 1; i <= 10000; i++) {
        n++;
    }
}
int main() {
    thread th[100];
    for (thread &x : th)
        x = thread(count10000);
    for (thread &x : th)
        x.join();
    cout << n << endl;
    return 0;
}
```

这里只是修改了变量的类型，其中 `std::atomic_int` 其实是 `std::atomic<int>` 的别名。这使得对该变量的操作是原子操作，即操作最小且不可并行化。这意味着即使是多线程，也要像同步进行一样**同步操作** atomic 对象，省去加锁解锁的耗时。

atomic 的具体介绍见 [Atomic](http://cplusplus.com/reference/atomic/atomic/)。

### 6.3. std::async

位于 future 头文件。大多数情况下使用 async 而不是 thread，`async` 可以根据情况选择同步执行或创建新线程来异步执行，也可以手动选择。对于 `async` 的返回值操作也比 thread 更加方便。

与 thread 不同，async 是一个函数，因而没有成员函数，重载如下：

|                           重载版本                           |                             作用                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| template <class Fn, class… Args><br/> future<typename result_of<Fn(Args…)>::type><br/>  async (Fn&& fn, Args&&… args) | 异步或同步（根据操作系统而定）以 args 为参数执行 fn。同样地，传递引用参数需要 `std::ref` 或 `std::cref` |
| template <class Fn, class… Args><br/> future<typename result_of<Fn(Args…)>::type><br/>  async (launch policy, Fn&& fn, Args&&… args); | 异步或同步（根据 `policy` 参数而定（见下文））以 args 为参数执行 fn，引用参数同上 |

`std::launch` 枚举类

| 标识符                | 实际值 | 作用 |
| :-------------------: | :----: | :----: |
|枚举值 launch::async | 0x1（1） | 异步启动 |
|枚举值 launch::deferred | 0x2（2） | 在调用 `future::get、future::wait` 时同步启动（`std::future` 见后文） |
|特殊值 launch::async｜launch::defereed | 0x3（3） | 同步或异步，根据操作系统而定 |

```c++
#include <iostream>
#include <thread>
#include <future>
using namespace std;
int main() {
    async(launch::async, [](const char *message){
        cout << message << flush;
    }, "Hello, ");
    cout << "World!" << endl;
    return 0;
}
```

### 6.4. std::future

#### future 获取线程返回值

之前创建线程的函数都没有接收返回值，如果需要获得函数的返回值，则可以使用 async 的返回值 future。

```c++
#include <iostream>
// #include <thread> // 这里我们用async创建线程
#include <future> // std::async std::future
using namespace std;

template<class ... Args> decltype(auto) sum(Args&&... args) {
    // C++17折叠表达式
    // "0 +"避免空参数包错误
    return (0 + ... + args);
}

int main() {
    // 注：这里不能只写函数名sum，必须带模板参数
    future<int> val = async(launch::async, sum<int, int, int>, 1, 10, 100);
    // future::get() 阻塞等待线程结束并获得返回值
    cout << val.get() << endl;
    return 0;
}
```

我们定义了一个函数 sum，它可以计算多个数字的和，之后我们又定义了一个对象 val，它的类型是 `std::future<int>`，这里的 int 代表这个函数的返回值是 int 类型。在创建线程后，我们使用了 `future::get()` 来阻塞等待线程结束并获取其返回值。

#### 常用成员函数

|                             函数                             |                             作用                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 一般：T get()<br/>当类型为引用：R& future<R&>::get()<br/>当类型为 void：void future::get() | 阻塞等待线程结束并获取返回值。<br/>若类型为 void，则与 `future::wait()` 相同。<br/>**只能调用一次。** |
|                      void wait() const                       |                       阻塞等待线程结束                       |
| template <class Rep, class Period><br/> future_status wait_for(const [chrono::duration](http://cplusplus.com/reference/chrono/duration/)<Rep,Period>& rel_time) const; | 阻塞等待 rel_time（rel_time 是一段时间），<br/>若在这段时间内线程结束则返回 `future_status::ready`<br/>若没结束则返回 `future_status::timeout`<br/>若 async 是以 `launch::deferred` 启动的，则不会阻塞并立即返回 `future_status::deferred`<br/> |

future 的作用并不只有获取返回值，还可以检测线程状态，因此存在 void 特殊的 futrue。

```c++
#include <iostream>
#include <future>
using namespace std;
void count_big_number() {
	// C++14标准中，可以在数字中间加上单
	// 引号 ' 来分隔数字，使其可读性更强
	for (int i = 0; i <= 10'0000'0000; i++);
}
int main() {
	future<void> fut = async(launch::async, count_big_number);
	cout << "Please wait" << flush;
	// 每次等待1秒
	while (fut.wait_for(chrono::seconds(1)) != future_status::ready)
		cout << '.' << flush;
	cout << endl << "Finished!" << endl;
	return 0;
}
```

### 6.5. std::promise

然而有时候可能也需要使用 thread，但是 thread 没有可用于获取返回值的函数，因此可以尝试使用引用传参来获取返回值。

promise 实际上是 std::future 的一个包装，如果使用 thread 以引用传递返回值的话，就必须要改变 future 的值，由于 future 的值不能被改变，这时候就需要使用 promise 的包装。

```c++
#include <iostream>
#include <thread>
#include <future> // std::promise std::future
using namespace std;

template<class ... Args> decltype(auto) sum(Args&&... args) {
    return (0 + ... + args);
}

template<class ... Args> void sum_thread(promise<long long> &val, Args&&... args) {
    val.set_value(sum(args...));
}

int main() {
    promise<long long> sum_value;
    thread get_sum(sum_thread<int, int, int>, ref(sum_value), 1, 10, 100);
    cout << sum_value.get_future().get() << endl;
    get_sum.join();
    return 0;
}
```

### 6.6. std::this_thread

在 `<thread>` 头文件中，不仅有 `std::thread` 这个类，而且还有一个 `std::this_thread` 命名空间，它可以很方便地让线程对自己进行控制。

#### 常用函数

|                             函数                             |                             作用                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|              std::thread::id get_id() noexcept               |                       获取当前线程 id                        |
| template<class Rep, class Period><br/>void sleep_for( const std::chrono::duration<Rep, Period>& sleep_duration ) |     等待 `sleep_duration`（`sleep_duration` 是一段时间）     |
|                    void yield() noexcept                     | **暂时**放弃线程的执行，将主动权交给其他线程，主动权还会回来。 |

```c++
#include <iostream>
#include <thread>
#include <atomic>
using namespace std;
atomic_bool ready = 0;
// uintmax_t ==> unsigned long long
void sleep(uintmax_t ms) {
    this_thread::sleep_for(chrono::milliseconds(ms));
}
void count() {
    while (!ready) this_thread::yield();
    for (int i = 0; i <= 20'0000'0000; i++);
    cout << "Thread " << this_thread::get_id() << " finished!" << endl;
    return;
}
int main() {
    thread th[10];
    for (int i = 0; i < 10; i++)
        th[i] = thread(::count);
    sleep(5000);
    ready = true;
    cout << "Start!" << endl;
    for (int i = 0; i < 10; i++)
        th[i].join();
    return 0;
}
```

### 6.7. std::call_once

c++11 提供了 `std::call_once` 来保证某一函数在多线程环境中只调用一次，它需要配合 `std::once_flag` 使用。

```c++
std::once_flag onceflag;

void CallOnce() {
    std::call_once(onceflag, []() {
        cout << "call once" << endl;
    });
}

int main() {
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread(CallOnce);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
```

### 6.8. thread_local

c++11 引入 thread_local，用 thread_local 修饰的变量具有 thread 周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。

```c++
#include <iostream>
#include <thread>

class A {
   public:
    A() {}
    ~A() {}

    void test(const std::string &name) {
        thread_local int count = 0;
        ++count;
        std::cout << name << ": " << count << std::endl;
    }
};

void func(const std::string &name) {
    A a1;
    a1.test(name);
    a1.test(name);
    A a2;
    a2.test(name);
    a2.test(name);
}

int main() {
    std::thread(func, "thread1").join();
    std::thread(func, "thread2").join();
    return 0;
}
```

对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于 static。

## 7. 智能指针

见[智能指针](./C++%20内存管理.md)。

## 8. 范围 for 循环

```c++
vector<int> vec;

for (auto iter = vec.begin(); iter != vec.end(); iter++) { // before c++11
    cout << *iter << endl;
}

for (int i : vec) { // c++11基于范围的for循环
    cout << "i" << endl;
}
```

## 9. 构造函数增强

### 9.1. 委托构造函数

```c++
struct A {
    A(){}
    A(int a) { a_ = a; }

    A(int a, int b) : A(a) { b_ = b; }

    A(int a, int b, int c) : A(a, b) { c_ = c; }

    int a_;
    int b_;
    int c_;
};
```

### 9.2. 继承构造函数

继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数。

```c++
struct Base {
    Base() {}
    Base(int a) { a_ = a; }

    Base(int a, int b) : Base(a) { b_ = b; }

    Base(int a, int b, int c) : Base(a, b) { c_ = c; }

    int a_;
    int b_;
    int c_;
};

struct Derived : Base {
    using Base::Base;
};

int main() {
    Derived a(1, 2, 3);
    return 0;
}
```

## 10. 关键字

### 10.1. nullptr

nullptr 是 c++11 用来表示空指针新引入的常量值，在 c++ 中如果表示空指针语义时建议使用 nullptr 而不要使用 NULL，因为 NULL 本质上是个 int 型的 0，其实不是个指针。

```c++
void func(void *ptr) {
    cout << "func ptr" << endl;
}

void func(int i) {
    cout << "func i" << endl;
}

int main() {
    func(NULL); // 编译失败，会产生二义性
    func(nullptr); // 输出func ptr
    return 0;
}
```

### 10.2. final & override

c++11 关于继承新增了两个关键字，final 用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override 用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 override 但父类却没有这个虚函数，编译报错，使用 override 关键字可以避免开发者在重写基类函数时无意产生的错误。

```c++
struct Base {
    virtual void func() {
        cout << "base" << endl;
    }
};

struct Derived : public Base{
    void func() override { // 确保func被重写
        cout << "derived" << endl;
    }

    void fu() override { // error，基类没有fu()，不可以被重写
    }
};
```

```c++
struct Base final {
    virtual void func() {
        cout << "base" << endl;
    }
};

struct Derived : public Base{ // 编译失败，final修饰的类不可以被继承
    void func() override {
        cout << "derived" << endl;
    }
};
```

### 10.3. default

通过 default，程序员只需在函数声明后加上"`=default;`"，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体。

```c++
struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a;
    return 0;
}
```

### 10.4. delete

c++ 中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，如拷贝构造函数或者拷贝赋值操作符。

```c++
struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a1;
    A a2 = a1;  // 正确，调用编译器隐式生成的默认拷贝构造函数
    A a3;
    a3 = a1;  // 正确，调用编译器隐式生成的默认拷贝赋值操作符
}
```

而我们有时候想禁止对象的拷贝与赋值，可以使用delete修饰：

```c++
struct A {
    A() = default;
    A(const A&) = delete;
    A& operator=(const A&) = delete;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a1;
    A a2 = a1;  // 错误，拷贝构造函数被禁用
    A a3;
    a3 = a1;  // 错误，拷贝赋值操作符被禁用
}
```

delele 函数在 c++11 中很常用，`std::unique_ptr` 就是通过 delete 修饰来禁止对象的拷贝的。

### 10.5. explicit

explicit 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换。

```c++
struct A {
    A(int value) { // 没有explicit关键字
        cout << "value" << endl;
    }
};

int main() {
    A a = 1; // 可以隐式转换
    return 0;
}
/* with explicit in another code */
struct A {
    explicit A(int value) {
        cout << "value" << endl;
    }
};

int main() {
    A a = 1; // error，不可以隐式转换
    A aa(2); // ok
    return 0;
}
```

### 10.6. constexpr

这里简单说明 `const`，表示某个变量或函数只读，表示某个变量不可更改，对于更改会在编译期间报错。

:one: 定义常量，修饰的变量不可更改

```c++
const int value = 5;
```

:two: 指针可以使用 const，看 const 之后紧跟的对象判断修饰的内容

```c++
char* const ptr;	// const紧跟的是变量本身，因此指针本身的指向不能改变
const char* ptr;	// const紧跟的是char*，因此指针指向的char数组内容不能改变
```

:three: 函数参数重使用 const 避免对象被修改

```c++
class A{};
void func(const A& a);
```

:four: const 修饰的成员变量不能被修改，可以在初始化列表中被赋值

```c++
class A {
    const int value = 5;
};
class B {
    const int value;
    B(int v) : value(v){}
};
```

:five: 修饰类成员函数，表示在该函数内不可以修改该类的成员变量

```c++
class A{
    void func() const;
};
```

:six: 修饰类对象，类对象只能调用该对象的 const 成员函数

```c++
class A {
    void func() const;
};
const A a;
a.func();
```

constexpr 是 c++11 新引入的关键字，用于编译时的常量和常量函数。const 和 constexpr 两者都代表可读，const 只表示 read only 的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而 constexpr 修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr 可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。

```c++
#include<iostream>
using namespace std;

constexpr int func(int i) {
    return i + 1;
}

int main() {
    int i = 2;
    func(i);// 普通函数
    func(2);// 编译期间就会被计算出来
}
```

### 10.7. sizeof 增强

C++11 中的 sizeof 可以直接使用在类的数据成员上而不需要事先定义一个对象

```c++
struct A {
    int data[10];
    int a;
};

int main() {
    A a;
    cout << "size " << sizeof(a.data) << endl; // before c++11
		cout << "size " << sizeof(A::data) << endl;// c++11 
    return 0;
}
```

### 10.8. assertion

```c++
static_assert(true/false, message);
```

c++11 引入 static_assert 声明，用于在编译期间检查，如果第一个参数值为 false，则打印 message，编译失败。

## 11. 类型

### 11.1. enum class

c++11 新增有作用域的枚举类型

```c++
enum AColor {
    kRed,
    kGreen,
    kBlue
};

enum BColor {
    kWhite,
    kBlack,
    kYellow
};

int main() {
    if (kRed == kWhite) {
        cout << "red == white" << endl;
    }
    return 0;
}
```

如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的 bug，而这种完全可以通过有作用域的枚举来规避。

```c++
enum class AColor {
    kRed,
    kGreen,
    kBlue
};

enum class BColor {
    kWhite,
    kBlack,
    kYellow
};

int main() {
    if (AColor::kRed == BColor::kWhite) { // 编译失败
        cout << "red == white" << endl;
    }
    return 0;
}
```

使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在 bug，同时带作用域的枚举类型可以选择底层类型，默认是 int，可以改成 char 等别的类型。

```c++
enum class AColor : char {
    kRed,
    kGreen,
    kBlue
};
```

### 11.2. 非受限联合体

c++11 之前 union 中数据成员的类型不允许有非 POD 类型，而这个限制在 c++11 被取消，允许数据成员类型有非 POD 类型（POD 类型见 [C++ 内存管理](./C++%20内存管理.md)）。

```c++
struct A {
    int a;
    int *b;
};

union U {
    A a; // 非POD类型 c++11之前不可以这样定义联合体
    int b;
};
```

### 11.3. 自定义字面量

C++ 自带四种字面量：整型、浮点型、字符、字符串，字面量可以添加后缀来表明具体类型，如：无符号整型 123u、长整型 123l。

C++11 允许用户自定义字面量后缀，但必须以'_'开头，非下划线开头的作为标准库保留使用的。

```c++
// typename0 operator"" _suffix(typename1 var) {}

long double 
operator"" _cm(long double x) {
  return x * 10;
}

long double 
operator"" _m(long double x) {
  return x * 1000;
}

long double 
operator"" _mm(long double x) {
  return x;
}

// height = 30.0
auto height = 3.0_cm; 

// length = 1230.0
auto length = 1.23_m;
```

如果使用这种写法，`_cm`, `_m`, `_mm` 等函数将在运行时被调用，如果希望在编译时就调用字面量后缀函数，则需要把函数定义为 `constexpr`。

#### 自定义字面量的限制

C++11 只允许字面量后缀函数的参数为以下类型，即整数，浮点以及字符串：

- `unsigned long long`
- `long double`
- `char const*`
- `char const*, std::size_t`
- `wchar_t const*, std::size_t`
- `char16_t const*, std::size_t`
- `char32_t const*, std::size_t`

返回值则无类型限制。

### 11.4. 基础数值类型

c++11 新增了几种数据类型：char16_t、char32_t 等。

## 12. 内存对齐

在 c++11 之前如果想创建内存对齐如下：

```c++
void align_cpp11_before()
{
    static char data[sizeof(void *) + sizeof(A)];
    const uintptr_t kAlign = sizeof(void *) - 1;
    char *align_ptr =
        reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(data + kAlign) & ~kAlign);
    A *attr = new (align_ptr) A;
}
```

C++11 关于内存对齐新增了一些函数

```c++
void align_cpp11_after()
{
    static std::aligned_storage<sizeof(A),
                                alignof(A)>::type data;
    A *attr = new (&data) A;
}
```

此外还有 `alignof()、std::alignment_of()、alignas()` 等，具体见 [C++ 内存管理](./C++内存管理.md)。

## 13. 随机数功能

c++11 关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型。c++11 提供的概率分布类型还有好多，例如伯努利分布、正态分布等。

```c++
#include <time.h>
#include <iostream>
#include <random>

using namespace std;

int main() {
    std::default_random_engine random(time(nullptr));

    std::uniform_int_distribution<int> int_dis(0, 100); // 整数均匀分布
    std::uniform_real_distribution<float> real_dis(0.0, 1.0); // 浮点数均匀分布

    for (int i = 0; i < 10; ++i) {
        cout << int_dis(random) << ' ';
    }
    cout << endl;

    for (int i = 0; i < 10; ++i) {
        cout << real_dis(random) << ' ';
    }
    cout << endl;

    return 0;
}
```

## 14. 正则表达式

c++11 引入了 regex 库更好地支持正则表达式

```c++
#include <iostream>
#include <iterator>
#include <regex>
#include <string>

int main() {
    std::string s = "I know, I'll use2 regular expressions.";
    // 忽略大小写
    std::regex self_regex("REGULAR EXPRESSIONS", std::regex_constants::icase); 
    if (std::regex_search(s, self_regex)) {
        std::cout << "Text contains the phrase 'regular expressions'\n";
    }

    std::regex word_regex("(\\w+)");  // 匹配字母数字等字符
    auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);
    auto words_end = std::sregex_iterator();

    std::cout << "Found " << std::distance(words_begin, words_end) << " words\n";

    const int N = 6;
    std::cout << "Words longer than " << N << " characters:\n";
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        if (match_str.size() > N) {
            std::cout << "  " << match_str << '\n';
        }
    }

    std::regex long_word_regex("(\\w{7,})");
    // 超过7个字符的单词用[]包围
    std::string new_s = std::regex_replace(s, long_word_regex, "[$&]");
    std::cout << new_s << '\n';
}
```

## 15. 时间库 chrono

chrono 库源于 boost，功能强大，主要有三个点：duration，time_point，clocks。

### 15.1. duration

`std::chrono::duration` 表示一段时间，常见的单位有 s、ms 等

```c++
// 拿休眠一段时间举例，这里表示休眠100ms
std::this_thread::sleep_for(std::chrono::milliseconds(100));
```

sleep_for 里面其实就是 `std::chrono::duration`，表示一段时间，实际是这样：

```c++
typedef duration<int64_t, milli> milliseconds;
typedef duration<int64_t> seconds;
```

duration 具体模板如下：

```c++
template <class Rep, class Period = ratio<1> > class duration;
```

Rep 表示一种数值类型，用来表示 Period 的数量，比如 int、float、double，Period 是 ratio 类型，用来表示【用秒表示的时间单位】比如 second，常用的 `duration<Rep, Period>` 已经定义好了，在 `std::chrono::duration` 下：

- ratio<3600, 1>：hours
- ratio<60, 1>：minutes
- ratio<1, 1>：seconds
- ratio<1, 1000>：microseconds
- ratio<1, 1000000>：microseconds
- ratio<1, 1000000000>：nanosecons

ratio 的具体模板如下：

```c++
template <intmax_t N, intmax_t D = 1> class ratio;
```

N 代表分子，D 代表分母，所以 ratio 表示一个分数，我们可以自定义 Period，比如 `ratio<2, 1>` 表示单位时间是2秒。

### 15.2. time_point

表示一个具体时间点，如 2020年5月10日10点10分10秒，拿获取当前时间举例：

```c++
std::chrono::time_point<std::chrono::high_resolution_clock> Now() { 
    return std::chrono::high_resolution_clock::now(); 
}
// std::chrono::high_resolution_clock为高精度时钟
```

### 15.3. clocks 

时钟类型，chrono 中提供了三种时钟：`steady_clock，system_clock，high_resolution_clock`。

#### steady_clock

稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用 now() 肯定比前一次调用 now() 的数值大，可用于计时。

#### system_clock

表示当前的系统时钟，可以用于获取当前时间：
更多介绍请看：[RAII 妙用之计算函数耗时](https://zhuanlan.zhihu.com/p/139519294)。

```c++
int main() {
    using std::chrono::system_clock;
    system_clock::time_point today = system_clock::now();

    std::time_t tt = system_clock::to_time_t(today);
    std::cout << "today is: " << ctime(&tt);

    return 0;
}
```

#### high_resolution_clock

high_resolution_clock 表示系统可用的最高精度的时钟，实际上就是 system_clock 或者 steady_clock 其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样。

## 16. 新增数据结构

`std::forward_list`：单向链表，只可以前进，在特定场景下使用，相比于 `std::list` 节省了内存，提高了性能。

```c++
std::forward_list<int> fl = {1, 2, 3, 4, 5};
for (const auto &elem : fl) {
    cout << elem;
}
```

- `std::unordered_set`：基于 hash 表实现的 set，内部不会排序，使用方法和 set 类似
- `std::unordered_map`：基于 hash 表实现的 map，内部不会排序，使用方法和 set 类似
- `std::array`：数组，在越界访问时抛出异常，建议使用 `std::array` 替代普通的数组
- `std::tuple`：元组类型，类似 `pair`，但比 `pair` 扩展性好

```c++
typedef std::tuple<int, double, int, double> Mytuple;
Mytuple t(0, 1, 2, 3);
std::cout << "0 " << std::get<0>(t);
std::cout << "1 " << std::get<1>(t);
std::cout << "2 " << std::get<2>(t);
std::cout << "3 " << std::get<3>(t);
```

## 17. 新增算法

- all_of：检测表达式是否对范围[first, last)中所有元素都返回 true，如果都满足，则返回 true

```c++
std::vector<int> v(10, 2);
if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; })) {
    std::cout << "All numbers are even\n";
}
```

- any_of：检测表达式是否对范围 [first, last) 中至少一个元素返回 true，如果满足，则返回 true，否则返回 false，用法和上面一样
- none_of：检测表达式是否对范围 [first, last) 中所有元素都不返回 true，如果都不满足，则返回 true，否则返回 false，用法和上面一样
- find_if_not：找到第一个不符合要求的元素迭代器，和 find_if 相反
- copy_if：复制满足条件的元素
- itoa：对容器内的元素按序递增

```c++
std::vector<int> l(10);
std::iota(l.begin(), l.end(), 19); // 19为初始值
for (auto n : l) std::cout << n << ' ';
// 19 20 21 22 23 24 25 26 27 28
```

- minmax_element：返回容器内最大元素和最小元素迭代器

```c++
int main() {
    std::vector<int> v = {3, 9, 1, 4, 2, 5, 9};

    auto result = std::minmax_element(v.begin(), v.end());
    std::cout << "min element at: " << *(result.first) << '\n';
    std::cout << "max element at: " << *(result.second) << '\n';
    return 0;
}
// min element at: 1
// max element at: 9
```

- is_sorted、is_sorted_until：返回容器内元素是否已经排好序。

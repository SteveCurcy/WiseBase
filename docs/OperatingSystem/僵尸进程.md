# 僵尸进程

## 僵尸进程

Linux 允许进程查询内核以获得其父进程的 PID，或者其任何子进程的执行状态。例如，进程可以创建一个子进程来执行特定的任务，然后调用诸如 wait() 这样的一些库函数检查子进程是否终止。如果子进程已经终止，那么它的终止代号将告诉父进程这个任务是否已成功地完成。

为了遵循这些设计原则，Linux 不允许内核在进程一终止后就丢弃包含在进程描述符字段中的数据。只有父进程发出了与被终止的进程相关的 wait() 类系统调用之后，才允许这样做。这就是引入僵死状态的原因：尽管从技术上来说进程已死，但必须保存它的描述符，直到父进程得到通知。 

如果一个进程已经终止，但是它的父进程尚未调用 wait() 或 waitpid() 对它进行清理，这时的进程状态称为僵死状态，处于僵死状态的进程称为僵尸进程 (zombie process)。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程都立刻被父进程清理了。

## 僵尸进程如何产生的

UNIX 系统中，一个进程结束了，但是他的父进程没有等待 (调用 wait/waitpid) 他，那么他将变成一个僵尸进程。通过 ps 命令查看其带有 defunct 的标志。僵尸进程是一个早已死亡的进程，但在进程表 (processs table) 中仍占了一个位置。 

但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由 init 进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而 init 进程会自动 wait 其子进程，因此被 init 接管的所有进程都不会变成僵尸进程。

- 子进程结束后向父进程发出 SIGCHLD 信号，父进程默认忽略了它；
- 父进程没有调用 wait/waitpid 函数来等待子进程结束

## Linux 对僵尸进程的处理

Linux 内核会自动扫描僵尸进程，并将其状态标记为僵尸进程，以提示父进程需要回收其资源。当父进程调用 wait() 或 waitpid() 等函数来回收子进程的资源时，内核会将僵尸进程从进程表中删除，并释放其占用的资源。

需要注意的是，虽然内核会自动扫描僵尸进程，但是如果父进程不及时回收子进程的资源，仍会导致僵尸进程的积累，从而占用系统资源，并可能影响系统的稳定性和性能。因此，确保父进程及时回收子进程的资源是保持系统正常运行的重要步骤之一。

## 僵尸进程的危害

在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(包括进程号 PID，退出状态，运行时间等)。直到父进程通过 `wait/waitpid` 来取时才释放。

如果进程不调用 `wait/waitpid` 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。

此外，如果产生大量僵尸进程，大量系统资源被占用，将会严重影响服务器的性能。

## 如何处理僵尸进程

僵尸进程的产生是因为父进程没有 wait 子进程，因此解决的方式就是在编程过程中在父进程中 wait 子进程；

手动杀死父进程（或者父进程创建子进程后立即退出），让僵尸进程成为孤儿进程，由 init 进程回收；
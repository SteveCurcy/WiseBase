# 写时复制机制

这里总结 Linux 中三个与复制相关的机制，分别是：COW，ROW，RCU。他们分别利用复制操作完成了数据的快照和同步。

## COW 和 ROW

我们称呼源数据所在的位置为『源卷』，快照存储的位置为『快照卷』，我们希望进行保护的数据称为『受保护实体』（Protected Entity）。

*COW（Copy On Write）* 和 *ROW（Redirect On Write）* 都是增量快照机制，都是虚拟拷贝而不是物理拷贝。一旦『受保护实体』遭遇破坏，则所有快照均失效。

快照有通常有两个目的：将来对删除或损坏的文件能进行恢复；作为副本/备份的源端（如备份快照，而不是备份源保护实体）。

COW 和 ROW 的主要区别是如何存储一个修改前的内容。

COW 是将旧数据拷贝出来，在原位置写新数据，尽量维持『受保护实体』的物理位置完整性；快照的存储比较分散；

ROW 是在新的位置写新的数据，然后将指针指向新的位置，当改写越多时，『受保护实体』的存储越分散；但是快照的物理位置完整性较强。

### COW

当『受保护实体』的某个 block（数据块）将被改写时，该 block 首先被 copy 到『快照卷』的某个位置，然后在『源卷』的 block 上进行改写。这种方法的每次写操作都需要 3 个 IO 操作，一次读和两次写。

- 读取快照时，由快照系统判断，需要的数据是否在快照中，如果不在则需要查询映射表去『源卷』中读取；
- 读取『源卷』时，与快照系统没有交互

COW 会降低源数据的写性能；当主机写入数据频繁时，这种方式将非常消耗 IO；无法得到完整的物理副本，快照仅保存修改部分的 block；copy 到快照系统中的数据量超过保留空间，快照就失效。

### ROW

ROW 中，当一个 block 将被改写时，快照系统将写请求重定向到快照预留空间，然后将新数据写到『快照卷』，从而避免了两次写操作引起的性能损失。当上层业务读取『受保护实体』时，快照创建前的数据从『源卷』中读取；快照创建后的数据从『快照卷』读取。

ROW 快照中的原始数据依然保存在『源卷』中，并且为了保证快照的完整性，『源卷』的状态会在创建快照时变为只读。

ROW 也没有保存完整的快照；创建多个快照时会产生快照链，使『受保护实体』的访问追踪以及快照的删除变得异常复杂；恢复快照时会不断合并快照文件，造成较大的系统开销；单机读性能下降，采用重定向写使得原本连续的数据分散到磁盘中，造成读性能下降。

ROW 不会降低写性能，所有写 IO 都被重定向到『快照卷』，快照数据保存在『源卷』；更新数据只需要一次写操作，解决了 COW 写性能问题；对于分布式系统来说，数据分散提供了并发读的机会，在分布式存储上，ROW 的连续读写性能比 COW 好。

综合来看：

- COW 更适合“读密集型”应用，或者对存储设备容易出现“写入热点”（对小范围数据写入频繁）的应用，因为数据修改局限在小范围内，对同一份数据的多次写只会出现一次复制操作；
- ROW 适合“写密集型”应用；重定向写的特性可能在分布式存储中，读性能会更高

## RCU

RCU (Read-Copy Update) 对于受保护的共享数据结构，读者不需要获得任何锁就可以访问它；但是写者在访问时需要先 Copy 一个副本，然后对副本进行修改，最后使用『回调』机制在适当的时机把指向原来数据的指针替换为新的被修改的数据。<mark>这个时机就是所有引用该数据的 CPU 都退出对共享数据的访问</mark>。

### 优点
RCU 是一种同步机制，适用于内核中频繁读但是无需频繁写的共享数据。它可以实现多线程无阻塞的读取数据，即使存在线程正在修改数据，读者也不会被阻塞且几乎没有额外的同步开销。

### 缺点
- RCU 读者访问的可能是旧数据，或者出现数据不一致；
- RCU 不保证在写线程开始后读线程可以读到更新后的数据，只能保证读取到的是旧数据或新数据，而不是部分修改的错误数据；
- 写者的性能较低

### RCU 读写操作
RCU 用于读取数据时的加解锁函数 `rcu_read_lock, rcu_read_unlock` 界定了读取侧的关键区。如果内和配置中开启了“CONFIG_PREEMPT”选项，那么这两个函数的工作仅仅是关闭和打开 CPU 的可抢占性，等同于 `preempt_disable, preempt_enable`；如果没有开启就什么都不做。

RCU 写侧，在完成拷贝和修改数据后，还要调用 `synchronize_rcu` 函数，用于和“引用旧数据指针”的 reader 进行同步：即等他们引用完成后，才释放旧指针指向的数据。

从调用同步函数到所有引用旧数据指针的 reader 退出的这段“同步等待”时间称为宽限区（Grace Period，GP）。这段时间保证了旧数据在使用完毕后才销毁。

### 等待与回调

但是如果 GP 这段时间比较长，而 writer 一直这样等待，可能影响 CPU 上更高优先级的任务执行。这种情况下，可以使用 `call_rcu` 来替换 `synchronize_rcu` 函数。

```C
void call_rcu(struct rcu_head *head, rcu_callback_t func);
```

`call_rcu` 会注册一个回调函数，当所有 reader 都退出『关键区』后，执行指定的回调函数。在调用 `call_rcu` 后就可以继续作其他工作了，当然也完全可能再次调用 `call_rcu`。因此注册的回调函数将会以链表的形式串联起来，在 GP 结束后依次执行。

回调函数的工作通常是释放“旧数据指针”指向的内存空间。

## 原文

[COW快照（copy-on-write）和ROW快照（redirect-on-write）的区别](https://blog.csdn.net/nirendao/article/details/79167842)

[快照技术（COW与ROW技术）](https://blog.csdn.net/qq_34474071/article/details/125199163)

[Linux中的RCU机制](https://zhuanlan.zhihu.com/p/595030489)

[Linux中的RCU机制[一] - 原理与使用方法](https://zhuanlan.zhihu.com/p/89439043)

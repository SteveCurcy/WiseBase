# 差分数组

前缀和主要适用于原始数组不会被修改的情况下，频繁查询某个区间的累加和。而『差分数组』的主要使用场景是频繁对原始数组的某个区间元素进行增减。

## 简介

假设：存在一个数组 num，用户给出大量修改操作 OP(l,r,val)，代表给数组区间 [l,r] 中的所有元素都加/减 val，最后求解数组的值。

最常规的思路就是，每次修改都遍历区间的每一个元素并进行增减。但是面对区间较大，操作频繁的场景，这种方式效率非常低。因此为了提高效率，我们就要用到『差分数组』。

## 算法介绍

我们对数组 num 构造『差分数组』 diff，其中 `diff[0] = num[0], diff[i] = num[i] - num[i - 1]`。

很明显地，我们可以通过『差分数组』反推出原始数组的值：`num[i] = diff[0]+...+diff[i]`。因此，如果我们对 diff[k] 加 val，就相当于对 num 数组区间 [k,...] 中的所有元素都加了 val。

这样一来，我们就可以快速进行区间增减操作。比如，你想对区间 [i,...,j] 的元素全部加 3，那么只需要 `diff[i] += 3, diff[j + 1] -= 3` 即可。因为：

- `diff[i] += 3` 相当于对 num[i,...] 的所有元素都加 3；
- `diff[j + 1] -= 3 相当于对 num[j + 1,...] 的所有元素都减 3（抵消了之前的加 3 操作）`

这样相当于只有 num[i,...,j] 的元素受到了“加 3”操作的影响，而我们每次只需要花费 O(1) 的时间复杂度就可以完成这样的区间修改操作。

## 代码

```java
/* 构造差分数组 */
void build() {
    diff[0] = num[0];
    for (int i = 1; i < num.length; i++) {
        diff[i] = num[i] - num[i - 1];
    }
}
/* 区间所有值增减操作 */
void modify(int l, int r, int val) {
    diff[l] += val;
    if (r + 1 < diff.length) {
        diff[r + 1] -= val;
    }
}
/* 求和 */
int sum() {
    int _sum = diff[0], _num = diff[0];
    for (int i = 1; i < diff.length; i++) {
        _num += diff[i];
        _sum += _num;
    }
    return _sum;
}
```

## 原文

[那些小而美的算法技巧：前缀和/差分数组](https://zhuanlan.zhihu.com/p/301509170)

# RMQ 问题

RMQ (Range Minimum/Maximum Query)，即区间最值查询。它描述了这样一类问题：

给定一个长度为 n 的数组 A，回答若干次询问 Q(A,i,j)(i,j <= n)，返回数组 A 区间 i 到 j 之间的最大/小值。

朴素的解决方案就是遍历，每次查询的时间复杂度都是 O(n)。但是当数据量较大且查询较为频繁时，这种算法将会超时。

对于 RMQ 问题的解决，通常有两种方法：ST 算法和线段树。ST 算法是在线算法；而线段树是一种离线算法。由于线段树较为复杂，本文将暂时只介绍 ST 算法。

> 在线算法：用户输入一个查询便马上处理一个查询；
>
> 离线算法：用户将输入数据全部给出后，程序再将查询的结果批量处理输出

ST (Sparse Table) 算法是著名的在线处理 RMQ 问题的算法，通常用较长的时间做预处理，待信息充足后，便可以用较少的时间回答每个查询。

## 预处理

ST 算法以 ST 表为基础，是倍增思想和 DP 结合的产物。它将预处理出 `[l,l+2^k)` 的区间最值。

我们假设：以求解最大值为例，a 是要求解区间最值的数组，dp(i,j) 表示数组 a 中，以 a[i] 为起点，长度为 2^j 的区间内的最大值（其中下标从 1 开始）。

显然有 `dp[i][0] = a[i]`。我们在 DP 中加入倍增的思想，每次将子区间的长度扩张一倍，可以得到状态转移方程：

```c
dp[i][j] = max{dp[i][j - 1], dp[i + 2^(j-1)][j - 1]}
```

按照 dp 数组的定义，我们将以 i 为起点，长度为 2^j 的区间的最值求解划分为两个长度为 2^(j-1) 的子区间的最值求解，区间的最值即两个子区间结果的最值。预处理的时间复杂度为 O(nlogn)。

## 查询

每次查询时，我们都需要找到一个 k，使得 `2^k <= r-l+1 <= 2^(k+1)`。这样，我们就可以将计算原区间 [l,r] 的最值转换为求 [l,l+2^k-1] 和 [r-2^k+1,r] 两个子区间的最值，时间复杂度主要在于求 `k = log(r-l+1)` 的地方，可以近似的看为 O(1)。

## 代码实现

```C
/* 预处理，计算 dp(i,j)
 * 由于我们是对区间进行倍增，所以我们应该从小区间递推到大区间；
 * 区间长度的遍历放在外循环，对于该长度的区间，计算所有起点的情况 */
void RMQ(int n) {
    int intval_index = log2(n);
    for (int j = 1, j <= intval_index; j++) {   /* 外循环遍历区间大小 */
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {  /* 内循环遍历区间的起始位置 */
            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
}
/* 查询操作 */
void query(int l, int r) {
    int k = log2(r-l+1);
    return max(dp[l][k], dp[r - (1 << k) + 1][k]);
}
```

## 原文

[浅析RMQ问题](https://zhuanlan.zhihu.com/p/396562513)

[RMQ算法详解](https://www.cnblogs.com/yoke/p/6949838.html)
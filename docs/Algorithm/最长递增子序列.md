# 最长递增子序列

这一问题是要求：在一个数组 nums 中，找到一个长度最长的子序列（不需要连续）。

在解决问题之前，我们首先要明确一些定义：什么是“子序列”。“子序列”和“子串/子数组”不同，“子序列”并不要求元素是连续的；但是“子串/子数组”要求是数组中的一段连续的元素。

最长递增子序列 (Longest Increasing Subsquence, LIS) 是非常经典的算法题。通常可以使用动态规划/贪心来解决。比较起来，可能动态规划更好理解，而『贪心+二分』更加抽象。

## 动态规划

动态规划的核心在于归纳。我们可以规定 `dp[i]` 表示以 num[i] 结尾的最长递增子序列的长度。由于子序列是不连续的，所以我们应该尝试“将当前元素加入之前所有子序列”的情况。那么我们可以得到递推公式：

```C
dp[i] = max{dp[0],...,dp[i - 1]}+1;
```

当然，要保证当前元素比之前子序列的结尾元素大。这样我们就可以得到一个 O(n^2) 的 DP。

```C++
for (int i = 0; i < num.length(); i++) {
    for (int j = i - 1; j >= 0; j--) {
        if (dp[i] > j) {
            /* 由于当前的最大长度比之前位置的元素数量都多，
             * 不可能有更优解了，直接退出即可 */
            break;
        }
        if (num[i] > num[j]) { /* 要保证递增 */
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
}
```

## 贪心 + 二分

我们可以考虑一下，我们每遇到一个元素应该如何处理。

我们在数组的遍历**过程**中，可能会遇到很多个长度相同的『递增子序列』。在这些子序列中，哪些更可能构成 LIS 呢？当然是末尾元素尽可能小的，因为这样你在后面遇到元素才能尽可能添加到该子序列的后面。

假设我们有这样一个数组 `{6,3,5,10,11,2,9,14,13,7,4,8,12}`。

那么我们遍历到第 2 个元素时，我们已经得到了两个递增子序列：{6},{3}。他们长度相同，但是很明显，{3} 在后续的遍历过程中更有**可能**加入更多的元素，进而成为 LIS。那么这个时候，我们就已经不再需要关注 {6} 这个子序列了，因为我们有更好的选择 {3}。

此外，我们有必要保存整个子序列吗？其实并没有必要，因为我们求解的是长度，而在尝试将一个元素加入到一个『递增自序列』中时，我们只关心它的末尾元素是什么。凭借末尾元素，我们就知道新元素能否加入这个序列了。

所以，我们可以定义这样一个数组 tails（下标从 1 开始）。`tails[i]` 代表长度为 i 的子序列的最后一个元素。这样的话，我们就可以通过一个数组保存了多个子序列的信息，包括长度信息和结尾元素。

这时我们再回过头来考虑，我们每次遇到一个元素应该如何处理呢？

假设我们当前遍历到 i，我们可以查找 tails 数组中第一个“大于 num[i]”的位置，假设位置是 k。这就意味着：

- k < num.length 时：说明有一个长度为 k 的『递增子序列』，它的末尾元素比 num[i] 更大；那么我们就可以将 num[i] 插入到长度为 k-1 的子序列构成一个长度为 k 的『递增子序列』，并且末尾元素比找到的子序列的更小；这样我们直接使用新构成的子序列代替我们找到的子序列（因为新的子序列更有可能成为 LIS），即 `tails[k] = num[i]`；
- k >= num.length 时：说明还没有一个子序列的末尾元素比 num[i] 更大，那我们把它添加到<mark>目前最长的递增子序列</mark>中即可，即将 num[i] 添加到 tails 数组的末尾，表示我们得到了一个更长的『递增子序列』

最终 tails 数组的长度即为 LIS 的长度。

那么现在，我们还面临一个问题：如何找到第一个大于 num[i] 的元素位置？如果使用倒序遍历那么与 DP 的做法就相同了，是 O(n^2)。我们可以使用二分进行优化，从而得到 O(nlogn) 的时间复杂度。

```C++
for (int i = 0; i < num.length(); i++) {
    int pos = upper_bound(tails.begin(), tails.end(), num[i]) - tails.begin();
    if (pos == tails.size()) {
        /* 没有找到比 num[i] 更大的，直接加入最长的递增子序列 */
        tails.push_back(num[i]);
    } else {
        tails[pos] = num[i];
    }
}
```